// Code generated by go-swagger; DO NOT EDIT.


{{ if .Copyright -}}// {{ comment .Copyright -}}{{ end }}

{{- /*TODO: do not hardcode cli pkg*/}}
package cli

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
    {{ imports .DefaultImports }}
    {{ imports .Imports }}

    "github.com/spf13/cobra"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/swag"
	httptransport "github.com/go-openapi/runtime/client"
)

// makeOperation{{pascalize .Package}}{{ pascalize .Name }}Cmd returns a cmd to handle operation {{ camelize .Name }}
func makeOperation{{pascalize .Package}}{{ pascalize .Name }}Cmd() (*cobra.Command, error) {
	cmd := &cobra.Command{
		Use:   "{{ .Name }}",
		Short: `{{.Description}}`,
		RunE: runOperation{{pascalize .Package}}{{ pascalize .Name }},
	}

	if err := registerOperation{{pascalize .Package}}{{ pascalize .Name }}ParamFlags(cmd); err != nil{
		return nil, err
	}

	return cmd, nil
}

// runOperation{{pascalize .Package}}{{ pascalize .Name }} uses cmd flags to call endpoint api
func runOperation{{pascalize .Package}}{{ pascalize .Name }}(cmd *cobra.Command, args []string) error{
	appCli, err := makeClient(cmd, args)
	if err != nil {
		return err
	}
	// retrieve flag values from cmd and fill params
	params := {{ .PackageAlias }}.New{{ pascalize .Name}}Params()
{{- range .Params }}
	{{- $flagStr := .Name }}
	{{- $flagValueVar := printf "%vValue" (camelize .Name) }}
		{{- /*only set the param if user set the flag*/}}
	if cmd.Flags().Changed("{{ $flagStr }}") {
	{{- if .IsPrimitive }}
		{{- if or (eq .GoType "int64") (eq .GoType "int32") (eq .GoType "string") (eq .GoType "float32") (eq .GoType "bool") }}
		{{ $flagValueVar }}, err := cmd.Flags().Get{{pascalize .GoType}}("{{ $flagStr }}")
		if err != nil{
			return err
		}
		{{- else }}
			// warning: primitive {{.GoType}} is not supported by go-swagger cli yet
		{{- end}}
	{{- else if and .IsBodyParam .Schema  }}
		{{- /*schema payload can be passed in cmd as a string and here is unmarshalled to model struct and attached in params*/}}
		// Read {{ $flagStr }} string from cmd and unmarshal
		{{ $flagValueVar }}Str, err := cmd.Flags().GetString("{{ $flagStr }}")
		if err != nil {
			return err
		}
		{{ $flagValueVar }} := {{.GoType}}{}
		if err := {{ $flagValueVar }}.UnmarshalBinary([]byte({{ $flagValueVar }}Str)); err!= nil{
			return fmt.Errorf("cannot unmarshal {{ $flagStr }} string in {{.GoType}}: %v", err)
		}
	{{- else }}
		// warning: {{.GoType}} is not supported by go-swagger cli yet
	{{- end }} {{/*end go type case*/}}
	{{- if .IsNullable }}
		params.{{ .ID }} = &{{ $flagValueVar }} 
	{{- else }}
		params.{{ .ID }} = {{ $flagValueVar }} 
	{{- end }}
	}
	{{- if and .IsBodyParam .Schema }}
		{{- /* Add flags to capture fields in Body. If previously Body struct was constructed in unmarshalling body string,
			then reuse the struct, otherwise construct an empty value struct to fill. Here body field flags overwrites
			unmarshalled body string values. */}}
		{{- $flagModelVar := printf "%vModel" (camelize $flagValueVar) }}
	{{ $flagModelVar }} := params.{{ .ID }}
	if swag.IsZero({{ $flagModelVar }}){
		{{ $flagModelVar }} = {{- if .IsNullable }}&{{- end }}{{.GoType}}{}
	}
		{{- /*Only attach the body struct in params if user passed some flag filling some body fields.*/}}
	err, added := retrieve{{ pascalize (dropPackage .GoType) }}Flags({{ $flagModelVar }}, "{{ camelize (dropPackage .GoType) }}", cmd)
	if err != nil{
		return err
	}
	if added {
		params.{{.ID}} = {{ $flagModelVar }}
	}
		{{- $bodyDebugVar := printf "%vDebugBytes" (camelize $flagValueVar) }}
	{{ $bodyDebugVar }}, err := json.Marshal(params.{{.ID}})
	if err != nil{
		return err
	}
	logDebugf("{{.ID }} payload: %v", string({{ $bodyDebugVar }}))
	{{- end }}
{{- end }}
	// make request and then print result
{{- /*Package string is the operation name*/}} {{/*TODO: this is broken for multi success response case*/}}
{{- if .Authorized}}
	resp, respErr := appCli.{{- pascalize .Package }}.{{ pascalize .Name }}(params, nil)
{{- else }}
	resp, respErr := appCli.{{- pascalize .Package }}.{{ pascalize .Name }}(params)
{{- end }}
	if err :=  printOperation{{pascalize .Package}}{{ pascalize .Name }}Result(resp, respErr); err != nil{
		return err
	}
	return nil
}

// printOperation{{pascalize .Package}}{{ pascalize .Name }}Result prints output to stdout
{{- /*TODO: handle multiple success response case*/}}
func printOperation{{pascalize .Package}}{{ pascalize .Name }}Result(resp *{{ .SuccessResponse.Package }}.{{ pascalize .SuccessResponse.Name }}, respErr error) error{
	if respErr != nil {
		{{- /*error is of type default model. If we can cast, then print the resp.*/}}
		{{- with .DefaultResponse }}
			{{ if .Schema }}
		var iResp interface{} = respErr
		defaultResp, ok := iResp.(*{{camelize .Package}}.{{ pascalize .Name }})
		if !ok {
			return respErr
		}
		if defaultResp.Payload != nil{
			msgStr,err := json.Marshal(defaultResp.Payload)
			if err != nil{
				return err
			}
			fmt.Println(string(msgStr))
			return nil
		}
			{{ else }}
			// Non schema case: warning {{.Name}} is not supported
			{{ end }}
		{{ end }}
		return respErr
	}
	{{- with .SuccessResponse }}
		{{ if .Schema }}
	if resp.Payload != nil {
		msgStr,err := json.Marshal(resp.Payload)
		if err != nil{
			return err
		}
		fmt.Println(string(msgStr))
	}
		{{ else }}
		// warning: non schema response {{.Name}} is not supported by go-swagger cli yet.
		{{ end }}
	{{ end }}
	return nil
}

// registerOperation{{pascalize .Package}}{{ pascalize .Name }}ParamFlags registers all flags needed to fill params
func registerOperation{{pascalize .Package}}{{ pascalize .Name }}ParamFlags(cmd *cobra.Command) error {
{{- range .Params }}
	{{- $fullDescription := .Description }}
	{{- $flagStr := .Name }}
	{{- if .Required}}
		{{- $fullDescription = printf "Required. %v" $fullDescription}}
	{{- end}}
	{{- if .IsPrimitive }}
		{{- if or (eq .GoType "int64") (eq .GoType "int32") (eq .GoType "string") (eq .GoType "float32") (eq .GoType "bool") }}
		{{ $defaultVar := printf "%vDefault" (camelize $flagStr) }}
		var {{ $defaultVar}} {{ .GoType }} {{ if .HasDefault }}= {{ printf "%#v" .Default }}{{ end }} 
		_ = cmd.PersistentFlags().{{ pascalize .GoType }}("{{ $flagStr }}", {{ $defaultVar }}, "{{ $fullDescription }}")
		{{- else }}
		// warning: primitive {{.GoType }} is not supported by go-swagger cli yet
		{{- end }}
	{{- else if and .IsBodyParam .Schema }}
		{{/* TODO: maybe the example string is not required? Some fields do not show up since marked as omitempty*/}}
		example{{pascalize .Name }}Str,err := json.Marshal(&{{ .GoType }}{})
		if err != nil {
			return err
		}
		_ = cmd.PersistentFlags().String("{{ $flagStr }}", "", fmt.Sprintf("Optional json string for {{ $flagStr }} of form %v.{{ .Description }}", string(example{{pascalize .Name }}Str)))
	{{- else }}
		// warning: go type {{ .GoType }} is not supported by go-swagger cli yet.
	{{- end }}
	{{/* mark required param for the flag, but not body string. Since the individial flag for body field will be added separately */}}
	{{- if and .Required (not (and .IsBodyParam .Schema))}}
		if err := cmd.MarkPersistentFlagRequired("{{ $flagStr }}"); err != nil{
			return err
		}
	{{ end }}
	{{- if and .IsBodyParam .Schema }}
		// add flags for body {{/*use go type as the flag prefix. There is no good way to determine the original str case in spec*/}}
		register{{ pascalize (dropPackage .GoType) }}Flags("{{ camelize (dropPackage .GoType) }}", cmd)
	{{- end }}
{{- end }} {{/*Params*/}}
	return nil
}